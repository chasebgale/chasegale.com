<!DOCTYPE html>
<html>
<head>
  <title>conquering mountains with technology</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <meta name="description">
  <meta property="og:type" content="website">
  <meta property="og:title" content="conquering mountains with technology">
  <meta property="og:url" content="http://chasegale.com/">
  <meta property="og:site_name" content="conquering mountains with technology">
  <meta property="og:description">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="conquering mountains with technology">
  <meta name="twitter:description">

  <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/vendor/fancybox/jquery.fancybox.css" media="screen" type="text/css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <!--
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-354944-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  -->
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body>
  <div id="container">
    <header id="header">
      <h1 class="blog-title">
		    <a href="/">conquering mountains with technology</a>
      </h1>
      <nav class="nav">
    		<ul>
    			<li><a id="nav-index-btn" href="/#index" class="nav-icon" title="Archive"><span class="nav-icon-title">  index</span></a></li>
    			<li><a id="nav-about-btn" href="/#about" class="nav-icon" title="About"><span class="nav-icon-title">  about</span></a></li>
    		</ul>
      </nav>
    </header>
    <div id="main"><article class="post">
	<header class="entry-header">
		<span class="date">
			Sep 12, 2011
		</span>
		<h1 itemprop="name" class="entry-title">
      <a class="article-title" href="/Raster-Text-In-HTML5-s-Canvas">Raster Text In HTML5's Canvas</a>
    </h1>
	</header>
	<div class="entry-content">
		<p>I love HTML5′s canvas. Armed with only a modern browser, we now have access to a plethora of drawing/imaging functionality with no third-party plugins required. Unfortunately, life isn’t all sunshine quite yet, echoed across the web is one resounding cry: &quot;<a href="http://simonsarris.com/blog/322-canvas-drawtext-considered-harmful">drawText is performance murder.</a>&quot; Even more unfortunately, the project I am currently building requires heaps (pun intended) of drawText() calls.</p>
<p>So, what to do? How do we quickly get a block of text onto a canvas? The answer is to manipulate the pixels of the canvas directly. I feel that code speaks louder than words, so let’s jump right in. First, you’ll need an image that represents our font:</p>
<p><img src="resource/bitmapfont_source.png" alt="bitmapfont source"></p>
<p>As you can see, I am using a bitmap font (no anti-aliasing) and I am outputting all characters in order, starting at charcode 33. <strong>Note: The lookup function we are going to write today depends entirely on these characters being in order.</strong> The next step is to load the font image into an off-screen buffer, or in our particular case, a hidden canvas element.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> fontImage = <span class="hljs-keyword">new</span> Image();
fontImage.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> bufferCanvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"bufferCanvas"</span>);
  <span class="hljs-keyword">var</span> bufferContext = bufferCanvas.getContext(<span class="hljs-string">"2d"</span>);

  bufferContext.drawImage(fontImage, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">566</span>, <span class="hljs-number">7</span>);
};
fontImage.src = <span class="hljs-string">"bitmapfont.png"</span>;
</code></pre>
<p>Now that we have our image drawn into the canvas, we are able to extract a representative array of pixels and begin processing them. The idea is to iterate over each block (every 4 elements of the array correspond to red, green, blue and alpha channels of a single pixel) and record the significant points for each character.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> fontPoints = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
<span class="hljs-keyword">var</span> fontImage = <span class="hljs-keyword">new</span> Image();
fontImage.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> bufferCanvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"bufferCanvas"</span>);
  <span class="hljs-keyword">var</span> bufferContext = bufferCanvas.getContext(<span class="hljs-string">"2d"</span>);

  bufferContext.drawImage(fontImage, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">566</span>, <span class="hljs-number">7</span>);

  <span class="hljs-keyword">var</span> w = <span class="hljs-number">566</span>;
  <span class="hljs-keyword">var</span> fontPixelArray = bufferContext.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w, <span class="hljs-number">7</span>);

  <span class="hljs-comment">// Store pointer directly to array of data to speed up lookups</span>
  <span class="hljs-keyword">var</span> fontPixelData = fontPixelArray.data;
  <span class="hljs-keyword">var</span> total = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">var</span> pointsLength = <span class="hljs-number">-1</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">95</span>; i++) {
    <span class="hljs-comment">// Each array element is an array that stores relative x and y coordinates</span>
    fontPoints[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; fontPixelData.length; i++) {
    <span class="hljs-comment">// Add up the R, G, B values</span>
    total = fontPixelData[i] + fontPixelData[i+<span class="hljs-number">1</span>] + fontPixelData[i+<span class="hljs-number">2</span>];

    <span class="hljs-comment">// If the total = 0 it's a black pixel, if not, we need to record it</span>
    <span class="hljs-keyword">if</span> (total &gt; <span class="hljs-number">0</span>) {
      x = i / <span class="hljs-number">4</span> % w;
      y = ( i / <span class="hljs-number">4</span> - x) / w;

      <span class="hljs-comment">// We can derive the character index by dividing by the character width</span>
      index = <span class="hljs-built_in">Math</span>.floor(x/<span class="hljs-number">6</span>);

      x = x - (index * <span class="hljs-number">6</span>);

      pointsLength = fontPoints[index].length;

      fontPoints[index][pointsLength] = {<span class="hljs-attr">x</span>: x, <span class="hljs-attr">y</span>: y};
    }

    i += <span class="hljs-number">3</span>;
  }
};
fontImage.src = <span class="hljs-string">"bitmapfont.png"</span>;
</code></pre>
<p>As illustrated above, we first create an array containing 94 child arrays – each will hold the significant points of the associated glyph; next, we iterate over the CanvasPixelData array in chunks of 4, screening out black pixels. Once we come upon a non-black point, we derive it’s relative coordinates and character index, then add the point to the appropriate array.</p>
<p>At this point, we have an array of coordinates to reproduce every glyph in our original image. As I’m sure you have anticipated, we now need a method we can invoke that will imprint these coordinates onto an existing image. Again, code speaks louder than words:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setPixel</span>(<span class="hljs-params">imageData, x, y, r, g, b, a</span>) </span>{
    index = (<span class="hljs-built_in">parseInt</span>(x) + <span class="hljs-built_in">parseInt</span>(y) * imageData.width) * <span class="hljs-number">4</span>;
    imageData[index+<span class="hljs-number">0</span>] = r;
    imageData[index+<span class="hljs-number">1</span>] = g;
    imageData[index+<span class="hljs-number">2</span>] = b;
    imageData[index+<span class="hljs-number">3</span>] = a;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rasterText</span>(<span class="hljs-params">imageData, text, x, y</span>) </span>{
    <span class="hljs-keyword">var</span> len = text.length;
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> code = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> characterPixelLength = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">var</span> startX = x;
    <span class="hljs-keyword">var</span> startY = y;

    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i &lt; len; i++) {
        code = text.charCodeAt(i) - <span class="hljs-number">33</span>;

        <span class="hljs-keyword">if</span> (code &gt; <span class="hljs-number">-1</span>) {
            characterPixelLength = fontPoints[code].length;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j &lt; characterPixelLength; j++) {
                setPixel(imageData,
                        startX + fontPoints[code][j].x,
                        startY + fontPoints[code][j].y,
                        <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0xFF</span>);
            }
        }

        startX += <span class="hljs-number">6</span>;
    }
}
</code></pre>
<p>Our new &quot;rasterText&quot; method accepts a string as one of it&#39;s parameters. For each character in this string, we lookup the number of points required to reproduce it, then for each of those points, we call the helper method &quot;setPixel.&quot; You&#39;ll also notice on line 19, we determine the index in our array by subtracting 33 from the character code. A space resolves to -1, but you&#39;ll notice we increase our &quot;startX&quot; outside that condition, so the space is preserved.</p>
<p>Here is how we would use this method from start to finish:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> destinationCanvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"destinationCanvas"</span>);
<span class="hljs-keyword">var</span> context = destinationCanvas.getContext(<span class="hljs-string">"2d"</span>);
<span class="hljs-keyword">var</span> imageData = context.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, context.width, context.height);

rasterText(imageData.data, <span class="hljs-string">"Hello World!"</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);

context.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre>
<p>Awesome! However, I&#39;m sure upon reflection you&#39;ll be identifying the limitations of this technique. Namely, you&#39;ll need to load and pre-process a different image for each font face and font size. Up front costs in terms of your effort, sure, but during testing my aforementioned project, text rendering time was reduced by a mean ~20%.</p>
<p>In closing, the method we built here today is by no means a nail in the text-rendering-poor-performance coffin. What it is, however, is another tool in your arsenal - I urge you to treat it like a scalpel, not a hammer.</p>

	</div>
</article>

<hr class="article-divider" />
<ins class="adsbygoogle"
		 style="display:block;width:728px;height:90px;margin: 0 auto;"
   	 data-ad-client="ca-pub-4898800745718155"
   	 data-ad-slot="4705512849"></ins>
<hr class="article-divider" />    </div>
    <footer id="footer">
      <span class="copyright">
        &copy; 2010-2017 <a href="/about">Chase Brandon Gale</a> | 
        Knowledge is power, use at your own risk.
      </span>
    </footer>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script src="/vendor/fancybox/jquery.fancybox.pack.js"></script>
    <script src="/js/index.js" type="text/javascript"></script>
    <script>
      [].forEach.call(document.querySelectorAll('.adsbygoogle'), function(){
          (adsbygoogle = window.adsbygoogle || []).push({});
      });
    </script>
  </div>
</body>
</html>